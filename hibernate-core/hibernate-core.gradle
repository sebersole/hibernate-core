import org.apache.tools.ant.filters.ReplaceTokens

/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
apply plugin: Antlr4Plugin
apply plugin: 'hibernate-matrix-testing'

apply plugin: 'org.hibernate.build.gradle.xjc'

configurations {
    hibernateJpaModelGenTool {
        description = "Dependencies for running the Hibernate JPA Metamodel Generator AnnotationProcessor tool"
    }
    tests {
        description = 'Configuration for the produced test jar'
    }
    asciidoclet {
        description = 'Configuration needed to enable the Asciidoctor JavaDoc doclet'
    }
}

dependencies {
    compile( libraries.jpa )
    compile( libraries.javassist )
    // provided until 6.0 when we make it the default and drop Javassist support
    provided( libraries.byteBuddy )
    compile( libraries.antlr )
    compile( libraries.jta )
    compile( libraries.jandex )
    compile( libraries.classmate )

    // We need dom4j for a number of things temporarily:
    //      1) (unsupported) EntityMode.DOM4J support
    //      2) Envers
    //      3) hibernate-commons-annotations
    compile( libraries.dom4j )
    compile( libraries.commons_annotations )

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Java 9 ftw!
    if ( JavaVersion.current().isJava9Compatible() ) {
        // The JDK used to run Gradle is Java 9+, and we assume that that is the same
        //		JDK for executing tasks
        xjc( 'com.sun.xml.bind:jaxb-impl:2.2.11' )
        xjc( 'org.glassfish.jaxb:jaxb-xjc:2.2.11' )
        xjc( 'org.jvnet.jaxb2_commons:jaxb2-basics:0.11.0' )
        xjc( 'org.jvnet.jaxb2_commons:jaxb2-basics-ant:0.11.0' )
        xjc( 'javax:javaee-api:7.0' )

        testCompile( 'com.sun.xml.bind:jaxb-impl:2.2.11' )
        testCompile( 'org.glassfish.jaxb:jaxb-xjc:2.2.11' )
        testCompile( 'org.jvnet.jaxb2_commons:jaxb2-basics:0.11.0' )
        testCompile( 'org.jvnet.jaxb2_commons:jaxb2-basics-ant:0.11.0' )
        testCompile( 'javax:javaee-api:7.0' )

        testRuntime( 'com.sun.xml.bind:jaxb-impl:2.2.11' )
        testRuntime( 'org.glassfish.jaxb:jaxb-xjc:2.2.11' )
        testRuntime( 'org.jvnet.jaxb2_commons:jaxb2-basics:0.11.0' )
        testRuntime( 'org.jvnet.jaxb2_commons:jaxb2-basics-ant:0.11.0' )
        testRuntime( 'javax:javaee-api:7.0' )
    }
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    antlr( libraries.antlr )

    provided( libraries.jacc )
    provided( libraries.validation )
    provided( libraries.ant )
    provided( "javax.enterprise:cdi-api:${cdiVersion}" )

    testCompile( project(':hibernate-testing') )
    testCompile( libraries.shrinkwrap_api )
    testCompile( libraries.shrinkwrap )
    testCompile( libraries.validation )
    testCompile( libraries.jandex )
    testCompile( libraries.classmate )
    testCompile( libraries.mockito )
    testCompile( 'joda-time:joda-time:2.3' )
//    testCompile( "org.jboss.weld:weld-core:2.3.4.Final" )
//    testCompile( "org.jboss.arquillian.container:arquillian-weld-ee-embedded-1.1:1.0.0.CR9" )
    compile( "javax.enterprise:cdi-api:${cdiVersion}" ) {
        // we need to force it to make sure we influence the one coming from arquillian
        force=true
    }

    testCompile( libraries.validator ) {
        // for test runtime
        transitive = true
    }

    // for testing stored procedure support
    testCompile( libraries.derby )

    testRuntime( "org.jboss.spec.javax.ejb:jboss-ejb-api_3.2_spec:1.0.0.Final" )
    testRuntime( libraries.expression_language_api )
    testRuntime( libraries.expression_language_impl )
    testRuntime( 'jaxen:jaxen:1.1' )
    testRuntime( libraries.javassist )
    testRuntime( libraries.byteBuddy )

    testCompile( project( ':hibernate-jpamodelgen' ) )

    testCompile libraries.arquillian_junit_container
    testCompile libraries.arquillian_protocol_servlet
    testCompile libraries.shrinkwrap_descriptors_api_javaee
    testCompile libraries.shrinkwrap_descriptors_impl_javaee
    testCompile libraries.wildfly_arquillian_container_managed

    testCompile libraries.jboss_ejb_spec_jar
    testCompile libraries.jboss_annotation_spec_jar

    asciidoclet 'org.asciidoctor:asciidoclet:1.+'
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Asciidoclet support
javadoc {
    options.docletpath = configurations.asciidoclet.files.asType(List)
    options.doclet = 'org.asciidoctor.Asciidoclet'
    options.overview = rootProject.file( "shared/javadoc/overview.html" ).absolutePath
    options.addStringOption "-base-dir", "${projectDir}"
    options.addStringOption "-attribute",
            "name=${project.name}," +
            "version=${project.version}," +
            "title-link=http://example.com[${project.name} ${project.version}]"
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


mavenPom {
    name = 'Core Hibernate O/RM functionality'
    description = 'The core O/RM functionality as provided by Hibernate'
}

def osgiDescription() {
	return mavenPom.description
}

jar {
    manifest {
        mainAttributes( 'Main-Class': 'org.hibernate.Version' )

        instructionFirst 'Import-Package',
            'javax.security.auth;resolution:=optional',
            'javax.security.jacc;resolution:=optional',
            'javax.validation;resolution:=optional',
            'javax.validation.constraints;resolution:=optional',
            'javax.validation.groups;resolution:=optional',
            'javax.validation.metadata;resolution:=optional',
            // TODO: Shouldn't have to explicitly list this, but the plugin
            // generates it with a [1.0,2) version.
            'javax.persistence;version="2.1.0"',
            // Temporarily support JTA 1.1 -- Karaf and other frameworks still
            // use it.  Without this, the plugin generates [1.2,2).
            // build.gradle adds javax.transaction for all modules
            'javax.transaction.xa;version="[1.1,2)"',
            // optionals
            'javax.management;resolution:=optional',
            'javax.naming.event;resolution:=optional',
            'javax.naming.spi;resolution:=optional',
            'org.apache.tools.ant;resolution:=optional',
			'org.apache.tools.ant.taskdefs;resolution:=optional',
			'org.apache.tools.ant.types;resolution:=optional',
            '!javax.enterprise*',
            'javax.enterprise.context.spi;resolution:=optional',
            'javax.enterprise.inject.spi;resolution:=optional'

//        // TODO: Uncomment once EntityManagerFactoryBuilderImpl no longer
//        // uses ClassLoaderServiceImpl.
//        instruction 'Export-Package',
//            'org.hibernate.boot.registry.classloading.internal',
//            '*'
    }
}

ext {
	jaxbTargetDir = file( "${buildDir}/generated-src/jaxb/main" )
}

sourceSets.main {
    java.srcDir jaxbTargetDir
}

// resources inherently exclude sources
sourceSets.test.resources {
    setSrcDirs( ['src/test/java','src/test/resources'] )
}

xjc {
    outputDir = jaxbTargetDir

    schemas {
        cfg {
            xsd = file( 'src/main/resources/org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd' )
            xjcBinding = file( 'src/main/xjb/hbm-configuration-bindings.xjb' )
        }
        hbm {
            xsd = file( 'src/main/resources/org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd' )
            xjcBinding = file( 'src/main/xjb/hbm-mapping-bindings.xjb' )
            xjcExtensions = ['inheritance', 'simplify']
        }
    }
}


//sourceSets.main.sourceGeneratorsTask.dependsOn xjc
//sourceSets.main.sourceGeneratorsTask.dependsOn generateGrammarSource
tasks.compile.dependsOn generateGrammarSource

// todo (6.0) : remove this once we get 6.0 stable-ish
tasks.withType( JavaCompile ).forEach({ JavaCompile c -> c.options.compilerArgs += ["-Xmaxerrs", "4999"]})

task copyBundleResources (type: Copy) {
    ext.bundlesTargetDir = file( "${buildDir}/bundles" )
    from file('src/test/bundles')
    into bundlesTargetDir
    ext.bundleTokens = dbBundle[db]
    ext.bundleTokens["buildDirName"] = buildDir.absolutePath
    filter( ReplaceTokens, tokens: bundleTokens);
    doFirst {
        bundlesTargetDir.mkdirs()
    }
}
processTestResources.dependsOn copyBundleResources

task testJar(type: Jar, dependsOn: testClasses) {
    classifier = 'test'
    from sourceSets.test.output
}

artifacts {
    tests testJar
}

task generateEnversStaticMetamodel(
        type: JavaCompile,
        description: "Generate the Hibernate Envers revision entity static metamodel classes." ) {
    source = sourceSets.main.java
    // we only want to include these specific classes for metamodel generation.
    // if envers adds any additional revision entity classes, they must be listed here.
    include 'org/hibernate/envers/DefaultRevisionEntity.java'
    include 'org/hibernate/envers/DefaultTrackingModifiedEntitiesRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdTrackingModifiedEntitiesRevisionEntity.java'

    classpath = sourceSets.main.runtimeClasspath + sourceSets.test.compileClasspath
    options.compilerArgs = [
            "-proc:only",
            "-processor",
            "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"
    ]

    // put static metamodel classes back out to the source tree since they're version controlled.
    destinationDir = new File( "${projectDir}/src/main/java" )
}

if ( JavaVersion.current().isJava9Compatible() ) {
    logger.warn( '[WARN] Skipping Javassist-related tests for hibernate-core due to Javassist JDK 9 incompatibility' )

    // we need to exclude tests using Javassist enhancement, which does not properly support
    // Java 9 yet - https://issues.jboss.org/browse/JASSIST-261
    test {
        // rather than wild-cards, keep an explicit list
        exclude 'org/hibernate/jpa/test/enhancement/InterceptFieldClassFileTransformerTest.class'
        exclude 'org/hibernate/jpa/test/enhancement/runtime/JpaRuntimeEnhancementTest.class'
        exclude 'org/hibernate/test/bytecode/enhancement/EnhancerTest.class'
        exclude 'org/hibernate/test/bytecode/enhancement/basic/BasicInSessionTest.class'

        // also, any tests using Arquillian for in-container testing with WildFly currently
        // need to be excluded because WildFly does not yet work with Java 9
        exclude 'org/hibernate/test/wf/ddl/**'
        exclude 'org/hibernate/jpa/test/cdi/**'
        exclude 'org/hibernate/envers/internal/tools/MapProxyTest.class'
        exclude 'org/hibernate/envers/test/integration/components/dynamic/AuditedDynamicComponentTest.class'
        exclude 'org/hibernate/envers/test/integration/components/dynamic/AuditedDynamicComponentsAdvancedCasesTest.class'
    }
}

processTestResources {
    doLast {
        copy {
            from file( 'src/test/resources' )
            into file( "${buildDir}/resources/test" )
            include 'arquillian.xml'
            include 'org/hibernate/test/wf/ddl/manifest.mf'
            expand wildFlyInstallDir: "${rootProject.buildDir.absolutePath}/wildfly-${wildflyVersion}",
                   hibernateMajorMinorVersion: "${rootProject.hibernateMajorMinorVersion}",
                   arquillianDeploymentExportDir: "${rootProject.buildDir.absolutePath}/arquillian-deployments"
        }
    }
}

test.dependsOn ":hibernate-orm-modules:prepareWildFlyForTests"

test {
    systemProperty "file.encoding", "utf-8"
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Custom Antlr v4 Plugin (to work with Gradle 3)

class Antlr4Plugin implements Plugin<Project> {
    void apply(Project project) {
        project.with {
            apply plugin : 'java'

            configurations.maybeCreate 'antlr'

            Antlr4GenerationTask genTask = tasks.create 'generateGrammarSource', Antlr4GenerationTask
            genTask.group = 'Build'
            genTask.description = 'Generate source code from ANTLR grammar'

            tasks.getByName('compileJava').dependsOn genTask

            SourceSet mainSourceSet = project.convention.getPlugin( JavaPluginConvention ).sourceSets.getByName( SourceSet.MAIN_SOURCE_SET_NAME );
            mainSourceSet.compileClasspath += configurations.antlr

            SourceSet testSourceSet = project.convention.getPlugin( JavaPluginConvention ).sourceSets.getByName( SourceSet.TEST_SOURCE_SET_NAME );
            testSourceSet.compileClasspath += configurations.antlr

            project.afterEvaluate({
                mainSourceSet.java.srcDir( genTask.outputDirectory )
            })

        }
    }
}

class Antlr4GenerationTask extends DefaultTask {
    String baseInputDirectory = 'src/main/antlr'
    String outputDirectoryPath = "generated-src/antlr/main"


    Map packageGrammarNames = ['org.hibernate.query.sqm.produce.internal.hql.grammar' :  ['HqlLexer.g4', 'HqlParser.g4'],
                                'org.hibernate.tool.hbm2ddl.grammar' : ['SqlStatementLexer.g4','SqlStatementParser.g4']]

    // A map where the key is the grammar file and the value the package name
    Map<File,String> sourceFilesPackageNames = [:]

    @InputFiles
    @SkipWhenEmpty
    FileCollection getSource() {
        List<String> sourceFileNames = []
        getAllSources().each { packageName, names ->
            names.forEach( {
                sourceFileNames.add(it)
                sourceFilesPackageNames.put(
                        this.getProject().file(it),
                        packageName
                )
            } )

        }
        return this.getProject().files( sourceFileNames )
    }

    // return Map where the key is the package name and the value is a list of grammar file belonging to the package
    Map<String,List<String>> getAllSources(){
        def result = [:];
        packageGrammarNames.each {
            packageName, names
                ->
                result.put(packageName, getPackageSources(packageName, names));
        }
        return result;
    }

    List<String> getPackageSources(packageName, names){
        names.collect {
            name -> baseInputDirectory + '/' + packageName.replace( '.', '/' ) + '/' + name
        }
    }

    @OutputDirectory
    File getOutputDirectory() {
        return project.file( "${project.buildDir}/${outputDirectoryPath}" )
    }

    @TaskAction
    void antlrGeneration() {
        logger.lifecycle( "Starting custom Antlr (v4) grammar generation" )
        source.forEach(
                { grammarFile ->
                    File packagedOutputDirectory = new File(
                            outputDirectory,
                            sourceFilesPackageNames.get( grammarFile ).replace( '.', '/' )
                    )

                    if ( !packagedOutputDirectory.exists() ) {
                        System.out.println( "#>>>> ${packagedOutputDirectory.absolutePath}" )
                        packagedOutputDirectory.mkdirs()
                    }

                    project.javaexec {
                        main 'org.antlr.v4.Tool'
                        classpath project.configurations.antlr
                        args '-o', packagedOutputDirectory.absolutePath
                        args '-lib', grammarFile.parentFile.absolutePath
                        args '-long-messages'
                        args '-listener'
                        args '-visitor'
                        args grammarFile.absolutePath
                    }


                }
        )
    }

}